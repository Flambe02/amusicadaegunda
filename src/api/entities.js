import { localStorageService } from '@/lib/localStorage';
import { supabaseSongService } from './supabaseService';
import { checkConnection } from '@/lib/supabase';

// Logs de debug supprim√©s

let currentStorageMode = 'unknown';

// ===== FORCER L'UTILISATION DE SUPABASE =====
let useSupabase = true; // Forcer Supabase

const detectStorageMode = async () => {
  try {
    console.warn('üîÑ Test de connexion Supabase...');
    
    // V√©rifier la connexion
    const isConnected = await checkConnection();
    
    if (isConnected) {
      console.warn('‚úÖ Mode de stockage: Supabase ‚òÅÔ∏è (connect√©)');
      useSupabase = true;
      currentStorageMode = 'supabase';
      return true;
    } else {
      console.warn('‚ö†Ô∏è Connexion Supabase √©chou√©e, mais on force quand m√™me Supabase');
      useSupabase = true; // FORCER SUPABASE m√™me si la connexion √©choue
      currentStorageMode = 'supabase';
      return true;
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Erreur d√©tection mode stockage, mais on force Supabase:', error);
    useSupabase = true; // FORCER SUPABASE m√™me en cas d'erreur
    currentStorageMode = 'supabase';
    return true;
  }
};

// Forcer la d√©tection imm√©diate
detectStorageMode().then(() => {
        console.warn(`üéØ Mode de stockage final: ${currentStorageMode === 'supabase' ? 'Supabase ‚òÅÔ∏è' : 'localStorage üíæ'}`);
});

// ===== ENTIT√âS AVEC FALLBACK AUTOMATIQUE =====
export const Song = {
  list: async (orderBy = '-release_date', limit = null) => {
    try {
      // Forcer l'utilisation de Supabase
      console.warn('‚òÅÔ∏è Chargement depuis Supabase...');
      const songs = await supabaseSongService.list(orderBy, limit);
      if (songs && songs.length > 0) {
        console.warn('‚úÖ Chansons charg√©es depuis Supabase:', songs.length);
        return songs;
      } else {
        console.warn('‚ö†Ô∏è Aucune chanson trouv√©e dans Supabase');
        return [];
      }
    } catch (error) {
      console.error('Erro ao carregar m√∫sicas desde Supabase:', error);
    }
    
    // Fallback vers data/songs.json si Supabase √©choue ou est vide
    try {
      console.warn('üîÑ Fallback vers data/songs.json...');
      const songs = localStorageService.songs.getAll();
      if (songs && songs.length > 0) {
        const sortedSongs = songs.sort((a, b) => new Date(b.release_date) - new Date(a.release_date));
        console.warn('‚úÖ Chansons charg√©es depuis localStorage:', songs.length);
        return limit ? sortedSongs.slice(0, limit) : sortedSongs;
      }
    } catch (localError) {
      console.error('Erro ao carregar m√∫sicas depuis localStorage:', localError);
    }
    
    // Dernier fallback : forcer l'initialisation du localStorage
    try {
      console.warn('üîÑ For√ßage initialisation localStorage...');
      localStorageService.initialize();
      const songs = localStorageService.songs.getAll();
      if (songs && songs.length > 0) {
        const sortedSongs = songs.sort((a, b) => new Date(b.release_date) - new Date(a.release_date));
        console.warn('‚úÖ Chansons charg√©es apr√®s initialisation forc√©e:', songs.length);
        return limit ? sortedSongs.slice(0, limit) : sortedSongs;
      }
    } catch (initError) {
      console.error('Erro ao for√ßar inicializa√ß√£o localStorage:', initError);
    }
    
    console.warn('‚ö†Ô∏è Aucune chanson trouv√©e, retour tableau vide');
    return [];
  },

  get: async (id) => {
    try {
      if (useSupabase) {
        return await supabaseSongService.get(id);
      } else {
        return localStorageService.songs.getById(id);
      }
    } catch (error) {
      console.error('Erro ao carregar m√∫sica:', error);
      return localStorageService.songs.getById(id);
    }
  },

  getCurrent: async () => {
    try {
      // Forcer l'utilisation de Supabase si disponible
      if (useSupabase) {
        const supabaseSong = await supabaseSongService.getCurrent();
        
        if (supabaseSong) {
          // Synchroniser avec localStorage pour compatibilit√©
          try {
            // Nettoyer d'abord le localStorage de "Confiss√µes Banc√°rias"
            const existingSongs = localStorageService.songs.getAll();
            const cleanedSongs = existingSongs.filter(song => 
              song.title !== 'Confiss√µes Banc√°rias' && 
              song.tiktok_video_id !== '7540762684149517590'
            );
            
            // Ajouter la chanson Supabase si elle n'existe pas d√©j√†
            const songExists = cleanedSongs.some(song => song.tiktok_video_id === supabaseSong.tiktok_video_id);
            if (!songExists) {
              cleanedSongs.push(supabaseSong);
            }
            
            // Renum√©roter les IDs et sauvegarder
            const renumberedSongs = cleanedSongs.map((song, index) => ({
              ...song,
              id: index + 1
            }));
            
            localStorage.setItem('songs', JSON.stringify(renumberedSongs));
            console.warn('üîÑ localStorage synchronis√© avec Supabase et nettoy√© de "Confiss√µes Banc√°rias"');
          } catch (localError) {
            console.warn('‚ö†Ô∏è Erreur synchronisation localStorage:', localError);
          }
          
          return supabaseSong;
        }
      }
      
      // Fallback localStorage seulement si Supabase n'a pas de donn√©es
              console.warn('‚ö†Ô∏è Supabase indisponible, utilisation du localStorage nettoy√©');
      return localStorageService.songs.getCurrent();
      
    } catch (error) {
      console.error('Erro ao carregar m√∫sica atual:', error);
      
      // En cas d'erreur, nettoyer le localStorage et essayer de r√©cup√©rer
      try {
        const existingSongs = localStorageService.songs.getAll();
        const cleanedSongs = existingSongs.filter(song => 
          song.title !== 'Confiss√µes Banc√°rias' && 
          song.tiktok_video_id !== '7540762684149517590'
        );
        
        if (cleanedSongs.length > 0) {
          // Renum√©roter et sauvegarder
          const renumberedSongs = cleanedSongs.map((song, index) => ({
            ...song,
            id: index + 1
          }));
          
          localStorage.setItem('songs', JSON.stringify(renumberedSongs));
          console.warn('üîÑ localStorage nettoy√© apr√®s erreur Supabase');
          
          // Retourner la premi√®re chanson nettoy√©e
          return renumberedSongs[0];
        }
      } catch (cleanupError) {
        console.error('‚ùå Erreur lors du nettoyage du localStorage:', cleanupError);
      }
      
      return null;
    }
  },

  create: async (songData) => {
    try {
      // Forcer l'utilisation de Supabase
      console.warn('‚òÅÔ∏è Cr√©ation via Supabase...');
      const result = await supabaseSongService.create(songData);
      console.warn('‚úÖ Cr√©ation Supabase r√©ussie:', result);
      return result;
    } catch (error) {
      console.error('‚ùå ERREUR CR√âATION SUPABASE:', error);
      console.error('‚ùå Message:', error.message);
      console.error('‚ùå Code:', error.code);
      console.error('‚ùå Details:', error.details);
      console.error('‚ùå Hint:', error.hint);
      
      // Fallback localStorage avec avertissement
      console.warn('üîÑ Fallback vers localStorage (Supabase a √©chou√©)...');
      console.warn('‚ö†Ô∏è ATTENTION: La chanson sera sauvegard√©e UNIQUEMENT en local!');
      console.warn('‚ö†Ô∏è Elle ne sera PAS visible sur le site public tant que Supabase ne fonctionne pas!');
      
      try {
        const localResult = localStorageService.songs.create(songData);
        console.warn('‚úÖ Chanson sauvegard√©e en localStorage:', localResult);
        console.warn('‚ö†Ô∏è RAPPEL: Cette chanson est LOCALE uniquement!');
        return localResult;
      } catch (localError) {
        console.error('‚ùå Fallback localStorage a aussi √©chou√©:', localError);
        throw new Error(`√âchec Supabase ET localStorage: ${error.message}`);
      }
    }
  },

  update: async (id, updates) => {
    try {
      // Forcer l'utilisation de Supabase
      console.warn('‚òÅÔ∏è Mise √† jour via Supabase...');
      console.warn('üìã Donn√©es √† mettre √† jour:', { id, updates });
      console.warn('üîç Type de l\'ID:', typeof id);
      console.warn('üîç Valeur de l\'ID:', id);
      
      console.warn('üîÑ Appel de supabaseSongService.update...');
      
      // Pas de fallback : si Supabase renvoie une erreur, on la laisse remonter
      const result = await supabaseSongService.update(id, updates);
      console.warn('‚úÖ R√©sultat de la mise √† jour Supabase:', result);
      
      // Synchronisation localStorage supprim√©e - on utilise uniquement Supabase
      console.warn('‚úÖ Mise √† jour Supabase r√©ussie - pas de synchronisation localStorage n√©cessaire');
      
      return result;
    } catch (error) {
      console.error('‚ùå ERREUR SUPABASE D√âTAILL√âE:', error);
      console.error('‚ùå Message d\'erreur:', error.message);
      console.error('‚ùå Code d\'erreur:', error.code);
      console.error('‚ùå D√©tails de l\'erreur:', error.details);
      console.error('‚ùå Hint:', error.hint);
      console.error('‚ùå Stack trace:', error.stack);
      console.error('‚ùå Erreur compl√®te:', JSON.stringify(error, null, 2));
      
      // NE PAS faire de fallback localStorage - forcer l'erreur
      console.error('‚ùå √âCHEC DE LA MISE √Ä JOUR SUPABASE - PAS DE FALLBACK');
      throw error; // Laisser l'erreur remonter sans la transformer
    }
  },

  delete: async (id) => {
    try {
      // Forcer l'utilisation de Supabase - PAS DE FALLBACK
      console.warn('‚òÅÔ∏è Suppression via Supabase...');
      const result = await supabaseSongService.delete(id);
      console.warn('‚úÖ Suppression Supabase r√©ussie:', result);
      return result;
    } catch (error) {
      console.error('‚ùå ERREUR SUPPRESSION SUPABASE:', error);
      console.error('‚ùå Message:', error.message);
      console.error('‚ùå Code:', error.code);
      // NE PAS faire de fallback localStorage - forcer l'erreur
      throw error;
    }
  },

  search: async (query) => {
    try {
      if (useSupabase) {
        return await supabaseSongService.search(query);
      } else {
        return localStorageService.songs.search(query);
      }
    } catch (error) {
      console.error('Erro ao pesquisar m√∫sicas:', error);
      return localStorageService.songs.search(query);
    }
  },

  getByStatus: async (status) => {
    try {
      if (useSupabase) {
        return await supabaseSongService.getByStatus(status);
      } else {
        const songs = localStorageService.songs.getAll();
        return songs.filter(song => song.status === status);
      }
    } catch (error) {
      console.error('Erro ao carregar m√∫sicas por status:', error);
      const songs = localStorageService.songs.getAll();
      return songs.filter(song => song.status === status);
    }
  },

  getByMonth: async (year, month) => {
    try {
      if (useSupabase) {
        return await supabaseSongService.getByMonth(year, month);
      } else {
        const songs = localStorageService.songs.getAll();
        const startDate = new Date(year, month - 1, 1);
        const endDate = new Date(year, month, 0);
        
        return songs.filter(song => {
          const songDate = new Date(song.release_date);
          return songDate >= startDate && songDate <= endDate;
        });
      }
    } catch (error) {
      console.error('Erro ao carregar m√∫sicas por m√™s:', error);
      const songs = localStorageService.songs.getAll();
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0);
      
      return songs.filter(song => {
        const songDate = new Date(song.release_date);
        return songDate >= startDate && songDate <= endDate;
      });
    }
  },

  getBySlug: async (slug) => {
    try {
      if (useSupabase) {
        // Essayer de r√©cup√©rer par slug depuis Supabase
        const songs = await supabaseSongService.list();
        const song = songs.find(s => s.slug === slug || s.title?.toLowerCase().replace(/\s+/g, '-') === slug);
        return song || null;
      } else {
        // Fallback localStorage
        const songs = localStorageService.songs.getAll();
        const song = songs.find(s => s.slug === slug || s.title?.toLowerCase().replace(/\s+/g, '-') === slug);
        return song || null;
      }
    } catch (error) {
      console.error('Erro ao carregar m√∫sica por slug:', error);
      // Fallback localStorage en cas d'erreur
      const songs = localStorageService.songs.getAll();
      const song = songs.find(s => s.slug === slug || s.title?.toLowerCase().replace(/\s+/g, '-') === slug);
      return song || null;
    }
  }
};

export const AdventSong = {
  list: async (orderBy = '-release_date', limit = 25) => {
    try {
      if (useSupabase) {
        // R√©cup√©rer les chansons de d√©cembre ou publi√©es
        const songs = await supabaseSongService.list(orderBy, limit);
        const adventSongs = songs.filter(song => {
          const releaseDate = new Date(song.release_date);
          const month = releaseDate.getMonth();
          return month === 11 || song.status === 'published';
        });
        return limit ? adventSongs.slice(0, limit) : adventSongs;
      } else {
        // Fallback localStorage
        const songs = localStorageService.songs.getAll();
        const adventSongs = songs.filter(song => {
          const releaseDate = new Date(song.release_date);
          const month = releaseDate.getMonth();
                  return month === 11 || song.status === 'published';
        });
        
        const sortedSongs = adventSongs.sort((a, b) => new Date(b.release_date) - new Date(a.release_date));
        return limit ? sortedSongs.slice(0, limit) : sortedSongs;
      }
    } catch (error) {
      console.error('Erro ao carregar m√∫sicas do Ano 2025:', error);
      // Fallback localStorage
      const songs = localStorageService.songs.getAll();
      const adventSongs = songs.filter(song => {
        const releaseDate = new Date(song.release_date);
        const month = releaseDate.getMonth();
        return month === 11 || song.status === 'published';
      });
      
      const sortedSongs = adventSongs.sort((a, b) => new Date(b.release_date) - new Date(a.release_date));
      return limit ? sortedSongs.slice(0, limit) : sortedSongs;
    }
  }
};

export const User = null;

// ===== FONCTIONS UTILITAIRES =====
export const switchToSupabase = async () => {
  const success = await detectStorageMode();
  if (success) {
    console.warn('‚úÖ Passage en mode Supabase activ√©');
  } else {
          console.warn('‚ùå Impossible de passer en mode Supabase');
  }
  return success;
};

export const switchToLocalStorage = () => {
  useSupabase = false;
      console.warn('üì± Passage en mode localStorage activ√©');
  return true;
};

export const getCurrentStorageMode = () => currentStorageMode;

export const isSupabaseAvailable = () => {
  return useSupabase;
};